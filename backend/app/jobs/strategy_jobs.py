from __future__ import annotations

import asyncio
import logging
import random
from datetime import datetime, timezone
from typing import List, Optional

from app.models.db import SessionLocal
from app.models.strategy import (
    StrategyRun,
    StrategyRunAsset,
    StrategyRunLog,
    HistoricalStrategyRun,
    StrategyNotification,
)

logger = logging.getLogger(__name__)

CANDIDATE_SYMBOLS = [
    "AAPL",
    "MSFT",
    "NVDA",
    "AMZN",
    "GOOGL",
    "META",
    "TSLA",
    "AVGO",
    "INTC",
    "AMD",
    "ORCL",
    "QCOM",
    "CRM",
]

PHASES = [
    ("signal_collection", "Collecting signals"),
    ("risk_filter", "Applying risk filters"),
    ("ranking", "Ranking candidates"),
    ("delivery", "Delivering results"),
]


def _now_iso() -> str:
    return datetime.now(timezone.utc).isoformat()



def _sample_assets(count: int) -> List[dict]:
    symbols = random.sample(CANDIDATE_SYMBOLS, min(count, len(CANDIDATE_SYMBOLS)))
    assets = []
    for symbol in symbols:
        strength = round(random.uniform(60.0, 99.0), 2)
        weight = round(random.uniform(0.05, 0.25), 3)
        asset = {
            "symbol": symbol,
            "signal_strength": strength,
            "weight": weight,
            "action": random.choice(["BUY", "INCREASE", "HOLD"]),
            "direction": "LONG",
            "risk_flags": ["VOLATILE"] if strength < 65 else [],
            "notes": "Generated by strategy engine",
            "signal_dimensions": {
                "momentum": round(random.uniform(0, 1), 2),
                "volume": round(random.uniform(0, 1), 2),
                "sentiment": round(random.uniform(0, 1), 2),
            },
        }
        assets.append(asset)
    return assets


async def _log_phase(session: AsyncSession, run: StrategyRun, phase: str, message: str) -> None:
    log_entry = StrategyRunLog(
        strategy_run_id=run.id,
        phase=phase,
        message=message,
        details={"timestamp": _now_iso()},
    )
    session.add(log_entry)
    await session.flush()


async def _record_notifications(session: AsyncSession, run: StrategyRun, final_status: str, task_id: Optional[str]) -> None:
    channels = run.notify_channels or []
    for channel in channels:
        note = StrategyNotification(
            strategy_run_id=run.id,
            channel=channel,
            status=final_status,
            payload={
                "phase": final_status,
                "task_id": task_id,
                "finished_at": _now_iso(),
            },
        )
        session.add(note)
    if not channels:
        session.add(
            StrategyNotification(
                strategy_run_id=run.id,
                channel="system",
                status=final_status,
                payload={"task_id": task_id, "phase": final_status},
            )
        )
    await session.flush()


async def execute_strategy_run_job(run_id: str, task_id: Optional[str] = None) -> None:
    async with SessionLocal() as session:
        from sqlalchemy import select
        from sqlalchemy.orm import selectinload
        
        stmt = select(StrategyRun).where(StrategyRun.id == run_id).options(
            selectinload(StrategyRun.strategy),
            selectinload(StrategyRun.history)
        )
        res = await session.execute(stmt)
        run = res.scalars().first()
        
        if not run:
            logger.warning("strategy run not found for job: %s", run_id)
            return

        if task_id and not run.celery_task_id:
            run.celery_task_id = task_id

        run.started_at = datetime.now(timezone.utc)
        run.status = "EXECUTING"
        run.attempt = (run.attempt or 0) + 1
        await session.commit()

        timeline = {}
        phase_start = datetime.now(timezone.utc)
        try:
            for phase_key, phase_label in PHASES:
                start = datetime.now(timezone.utc)
                await _log_phase(session, run, phase_key, phase_label)
                timeline[phase_key] = {"start": start.isoformat(), "end": ""}
                await asyncio.sleep(0.1)
                timeline[phase_key]["end"] = datetime.now(timezone.utc).isoformat()

            candidate_count = min(len(CANDIDATE_SYMBOLS), 5)
            sampled = _sample_assets(candidate_count)

            assets_records = []
            total_strength = 0.0
            for asset_payload in sampled:
                asset = StrategyRunAsset(
                    strategy_run_id=run.id,
                    symbol=asset_payload["symbol"],
                    signal_strength=asset_payload["signal_strength"],
                    signal_dimensions=asset_payload["signal_dimensions"],
                    weight=asset_payload["weight"],
                    action=asset_payload.get("action", "BUY"),
                    direction=asset_payload.get("direction", "LONG"),
                    risk_flags=asset_payload["risk_flags"],
                    notes=asset_payload["notes"],
                )
                session.add(asset)
                assets_records.append(asset)
                total_strength += asset_payload["signal_strength"]
            await session.flush()

            avg_strength = total_strength / candidate_count if candidate_count else 0.0
            history = HistoricalStrategyRun(
                strategy_run_id=run.id,
                hits=candidate_count,
                scanned_total=100,
                hit_rate=round(candidate_count / 100, 4),
                avg_signal_strength=round(avg_strength, 2),
                assets=sampled,
                timeline=timeline,
                notify_channels=run.notify_channels,
                status_payload={"status": "COMPLETED" if candidate_count else "FAILED"},
            )
            session.add(history)

            run.status = "COMPLETED"
            run.finished_at = datetime.now(timezone.utc)
            if run.strategy:
                run.strategy.last_run_status = run.status
                run.strategy.last_run_at = run.finished_at
            await _record_notifications(session, run, run.status, task_id)
            await session.commit()
            logger.info("strategy run %s completed", run.id)
        except Exception as exc:
            await session.rollback()
            async with SessionLocal() as err_session:
                from sqlalchemy import select
                from sqlalchemy.orm import selectinload
                
                stmt = select(StrategyRun).where(StrategyRun.id == run_id).options(
                    selectinload(StrategyRun.strategy)
                )
                res = await err_session.execute(stmt)
                failed_run = res.scalars().first()
                
                if not failed_run:
                    logger.error("strategy run %s disappeared after exception", run_id)
                    return
                failed_run.status = "FAILED"
                failed_run.error_message = str(exc)
                failed_run.finished_at = datetime.now(timezone.utc)
                if failed_run.strategy:
                    failed_run.strategy.last_run_status = failed_run.status
                    failed_run.strategy.last_run_at = failed_run.finished_at
                await err_session.commit()
            logger.exception("strategy run failed %s", run.id)
            return
